<img src="https://habrastorage.org/files/4b9/301/272/4b93012723ed4c22bc82d1b4bd765335.jpg"/>
Современные виртуальные машины стали настолько сложными, что в некоторых случаях, могут представлять собой пресловутый черный ящик. 
Поэтому если вам интересен рассказ о том, как написать простую (но далеко нетривиальную) виртуальную машину, а затем прикрутить к ней сверху компилятор, и в итоге получить свой язык программирования, при этом не используя никаких сторонних решений и
фреймворков - прошу под кат.
<cut />
<h2> Предыстория </h2>
У нас в университете (СПб ИТМО) любят давать студентам интересные и, зачастую не самые простые, задания. Вот и я, прослушав интересный семестровый курс под названием "Языки системного программирования", не смог пройти мимо такого челленджа и взял проект. Мне было предложено написать языковую виртуальную машину, ну а потом уже пришла логичная мысль прикрутить к ней сверху компилятор, чтобы в итоге получить простенький, но зато свой язык программирования.
В качестве основного языка был выбран F# по двум причинам : <ol>
	<li>Мне нравится F# </li>
        <li>Функциональная парадигма в 90% случаев облегчает написание, в то же время в оставшихся 10% случаев я могу использовать "нефункциональную" сторону F# </li>
</ol>

<h2> Из чего состоит рассказ </h2>
Уместить все основные моменты написания машины и компилятора, при этом не упустив ничего интересного/важного, в одну статью, пускай и большую, не выходит. Поэтому было решено разбить рассказ на две основные темы : <ol>
	<li>Написание виртуальной машины </li>
        <li>Написание компилятора, ориентированного на ранее описанную ВМ</li>
</ol>
И перед началом рассказа, сразу поделюсь ссылкой на <a href="https://github.com/yurijvolkov/sysProgrammingProject">репозиторий с этим проектом</a>, ведь вместить весь код в статью у меня не получится.


<h2> Языковая виртуальная машина </h3>
Итак, для начала определение : <blockquote>Виртуальная машина - это программа, реализующая поведение некоторого физического устройства (которое, кстати говоря, может и не существовать в реальности).</blockquote> Тут сразу важная отметка, что писать мы будем именно языковую виртуальную машину, а не системную. Если интересно в чём различие, то на хабре есть отличная       <a href="https://habrahabr.ru/company/intel/blog/254793/">статья</a>, разжевывающая этот вопрос. 
Основных типов виртуальных машин всего два :<ul>
	<li>Стековые</li>
        <li>Регистровые</li>
</ul>
У первых всё крутится вокруг стека(ов) и они гораздо проще в реализации. Две, пожалуй, самые известные языковые виртуальные машины : CLR и JVM относятся к стековым. Регистровые машины, гораздо более сложны во внутреннем устройстве, но также не лишены преимуществ. Мы будем писать именно стековую машину. 

<h3> Шаг 1: Система типов </h3>
В основе любой языковой виртуальной машины лежит система типов - это структуры данных, описывающие, что же она представляет из себя. На вход для исполнения машина получает файлы, содержащие в себе набор функций. Затем загрузчик (до которого разговор дойдёт), ищет функцию с именем "main" и машина начинает, команда за командой, исполнять код. Сама функция описывается следующим типом :
<source lang="fsharp">type Function =  {
        fileId : int64 // id файла, из которого загрузчик достал функцию
        nameId : int64 // id имени функции, лежащего в пуле строк
        localsCount : int64 //количество локальных перемнных
        flags : int64 //некоторые флаги (на данный момент это поле не используется) 
        argsCount : int64 
        args : byte list //типы аргументов (Look : enum SupportedTypes)
        byteCodeSize : int64
        code : byte list
    }</source>

Во время исполнения наша машина представляет из себя цепочку выполняемых контекстов.
Контекст - это сама функция и текущее состояние её исполнения :<ul>
	<li>Текущая исполняемая команда</li>
        <li>Instance самой функции</li>
        <li>Состояние всех локальных переменных </li>
</ul> 
Тип, описывающий контекст выглядит следующим образом :
<source lang="fsharp">type VmCtx = {
        command : byte list;
        func : Function;
        locals : VmValue[]; //локальные переменные
    }</source>
В какой-то момент машина может содержать в себе несколько контекстов, исполняющих одну и ту же функцию, тем не менее каждый контекст имеет разное состояние выполнения.
Таким образом, мы можем организовать хоть миллион рекурсивных вызовов, тем не менее, храня контекст, мы всегда можем продолжить исполнение функции, не опасаясь, что рекурсивные вызовы затрут её состояние.

Тут сразу отмечу первую загвоздку с которой столкнулся. Люди, знакомые с принципами работы процессоров, понимают, что в любом случае, должен быть какой-то счетчик команд (СК), хранящий в себе указатель на следующую исполняемую команду. Тем не менее, мы пишем на функционально-ориентированном F#, поэтому такой способ нам не подходит. Выход я нашёл простой, давайте хранить весь код функции в списке command, и каждый раз "отрезать" с головы одну команду и исполнять её. 
Тут локальные переменные хранятся в массиве из элементов типа VmValue. Это единый тип для всех переменных в нашей виртуальной машине. Представляет он из себя просто массив байт, которые мы вольны интерпретировать как любой тип : целочисленный, с плавающей точкой или вовсе как указатель на строку. Разумеется ответственность за верную интерпретацию ложится на нас.
<source lang="fsharp"> type VmValue = { arr : byte[] }
        with
            static member Cons (arr : byte[]) = {arr=arr} 
            member v.ToInt16() = BitConverter.ToInt16(v.arr,0)
            member v.ToInt32() = BitConverter.ToInt32(v.arr,0)
            member v.ToInt64() = BitConverter.ToInt64(v.arr,0)
            member v.ToBoolean() = BitConverter.ToBoolean(v.arr,0)
            member v.ToChar() = BitConverter.ToChar(v.arr, 0)
            member v.ToSingle() = BitConverter.ToSingle(v.arr, 0)
            member v.ToDouble() = BitConverter.ToDouble(v.arr, 0)
            member v.ToUInt16() = BitConverter.ToUInt16(v.arr, 0)
            member v.ToUInt32() = BitConverter.ToUInt32(v.arr, 0)
            member v.ToUInt64() = BitConverter.ToUInt64(v.arr,0)
            member v.ToStrPtr() = (BitConverter.ToInt32(v.arr,0),
                                   BitConverter.ToInt32(v.arr,4))</source>
Теперь мы подобрались к главному типу в этом проекте. А именно к типу, непосредственно описывающему текущее состояние машины:
<source lang="fsharp">type Vm = {
        context : VmCtx list;
        dataStack : Stack.stack<VmValue>;
        stringPool : (int64 * int64 * string) list ; //(file Id * name Id * string)
        functions : Function list;
     } 
</source>
Тут, как раз и видим, что виртуальная машина - это просто последовательность контекстов. Каждый раз мы будем брать верхний контекст, выполнять из него следующую команду. И так до тех пор, пока список контекстов не станет пустым. К тому же тут хранится стек данных. Он один на всю машину, именно через него происходит передача аргументов. Код описания стека, я не выкладываю, его можно посмотреть в файле <a href="https://github.com/yurijvolkov/sysProgrammingProject/blob/master/vm_fsharp/Types.fs">Types.fs</a>. 
В пуле строк о каждой строке мы храним id файла, из которого мы её взяли, id строки именно в том файле, а также саму строку. 
Таким образом мы получили систему типов нашей языковой машину, которая полностью определяет текущее состояние исполнения.

<h3> Шаг 2: Загрузчик (Loader) </h3>
Файлы с кодом для исполнения на виртуальной машине, прежде всего подаются на вход загрузчику. Каждый из файлов имеет следующую структуру :
<ul>
<li>Magic numbers : 0xba 0xba (2 байта)</li>
<li>Версия машины: 1 (8 байт)</li>
<li>Смещение, с которого начинается описание функций : (8 байт)</li>
<li>Пул констант : 
<ul>
	<li>Количество констант : (8 байт)</li>
	<li>Константы, разделенные "\0"</li>
</ul> </li>
<li>Количество функций в данном файле : (8 байт)</li>
<li>Функции :
<ul>
	<li>ID имени функции (в пуле констант) : (8 байт)</li>
	<li>Количество локальных переменных : (8 байт)</li>
	<li>Флаги : (8 байт)</li>
	<li>Количество аргументов : (8 байт)</li>
	<li>Типы аргументов : (1 байт для каждого аргумента)</li>
	<li>Длина байт-кода : (8 байт)</li>
	<li>Байт-код : (1 байт для каждой команды и 8 для каждого VmValue)</li>
</ul> </li>
</ul>
 Загрузчик парсит все переданные файлы и складывает данные в ранее описанные типы. Затем ищется функция с именем "main", и для неё инициализируется первый контекст, который и начнёт исполняться первым. 
<source lang="fsharp">let vmInit files = 
    let parse = parseFiles files
    let functions = fst parse
    let pool = snd parse
    let main = List.find (fun f -> getStr pool f.fileId f.nameId = "main" ) functions
    {context=[vmCtxInit main]; dataStack=Stack.empty;
     stringPool=pool; functions=functions}
</source>

<source lang="fsharp">let vmCtxInit func =
    {command=func.code; func=func; locals=Array.zeroCreate (int func.localsCount)}
</source>
Разумеется это только две "верхние" функции загрузчика, но именно они и отражают принцип работы загрузчика. Остальные функции ничего интересного не содержат, там лишь технический парсинг байт, требующий лишь аккуратности, но никак не изобретательности. Их можно посмотреть в файле <a href="https://github.com/yurijvolkov/sysProgrammingProject/blob/master/vm_fsharp/Loader.fs">Loader.fs</a>.

<h3> Шаг 3: Система команд </h3>
На данный момент машина уже полностью инициализирована и готова к исполнению. Там лежит контекст функции "main", содержащий байт-код, который мы должны начать исполнять. Осталось лишь разобраться, как нам интерпретировать каждую последовательность байт. Для этого и нужно построить отображение множества команд, которые машина должна поддерживать, в множество всевозможных значений одного байта памяти. Для этого определим тип Commands :
<source lang="fsharp">  type Commands = 
        |INVALID=0uy    //Invalid instruction
        |LOAD=1uy       //Loads inlined value
        |LOADS=2uy      //Loads inlined Id of string
        |DADD=3uy       //Double addition
        |IADD=4uy       //Int addition
        |DSUB=5uy       //Double subtraction
        |ISUB=6uy       //Int subtraction
        |IPRINT=14uy    //Pop and print integer on TOS
        |I2D=17uy       //Convert int on TOS to double
        |LOADVAR=22uy   //Load variable whose 4-byte Id is inlined 
        |LOADSVAR=23uy  //Same as LOADVAR
        |STOREVAR=25uy  //Store value form TOS in variable whose 4-byte id is inlined
        |JA=29uy        //Jump for give 4-byte offset
        |DUMP=46uy      //Dublicate TOS
        |STOP=47uy      //Stops virtual machine
        |CALL=48uy      //Call function with inlined 4bytes fileId, 4bytes nameId
        |RETURN=49uy    //Return to call location
        |BREAK=50uy     //Breakpoint (NOT IMPLEMENTED)
        .......
</source>
Всего машина поддерживает 51 команду. В статью я вставлю лишь малую часть из них. Остальные команды и описания к ним можно посмотреть в файле <a href="https://github.com/yurijvolkov/sysProgrammingProject/blob/master/vm_fsharp/Commands.fs">Commands.fs</a>.
Таким образом мы получили аналог Си-шарповского enum'а. Теперь определив семантику каждой команды мы можем переходить к непосредственному исполнению байт-кода.

 <h3> Шаг 4: Исполнение байт-кода </h3>
Основных способов исполнения байт-кода в виртуальных машинах можно выделить 3.
<img src="https://habrastorage.org/files/d45/8b7/82a/d458b782a7224e4c81eed4506c8e89d5.PNG"/>
<ul>
	<li>Интерпретация - основная техника исполнения, которая относительно проста в реализации </li>
	<li> Динамическая трансляция - техника, гораздо более сложная, она основана на принципе, что команды при исполнении могут образовывать циклы, которые мы можем использовать для ускорения исполнения   </li>
	<li> Статическая трансляция - техника, которая относительно редко применима, ведь не предполагает подгрузки новых блоков кода во время исполнения  </li>
</ul>
Мы будем использовать технику интерпретации. Тут же мы вспоминаем, что в простейшем случае интерпретация представляет из себя просто switch по всем командам. Так как мы пишем на F#, то получаем не swicth, а match.  
<source lang="fsharp">let rec execute (vm : Vm) = 
    match vm with
    |{context=[]} -> ignore 1
    |{context=h::t} -> 
        let command : Commands = LanguagePrimitives.EnumOfValue (head h.command)
        match command with 
        | Commands.INVALID  -> printfn "Runtime error : invalid byte command."
        | Commands.LOAD -> 
            let split = List.splitAt 8 (tail h.command)
            let dataStack = Stack.push vm.dataStack (VmValue.Cons (List.toArray(fst split)))
            let ctx = {command=snd split; func=h.func; locals=h.locals}
            execute {context=ctx::t; dataStack=dataStack; stringPool=vm.stringPool; functions=vm.functions}</source>
Для получения следующей исполняемой команды, мы должны взять верхний контекст из нашей машины и исполнить верхнюю команду этого контекста. Затем изменить состояние этого контекста, положить его на верх списка контекстов (при необходимости) и повторить эту последовательность действий снова, и так далее, до тех пор, пока верхнего контекста не окажется. 
Это всё реализовано в одной большой и страшной функции execute, принимающей на вход обьект типа Vm, то есть текущее состояние машины. Опять же в силу масштабов этой функции, в статью я вставлю только самый-самый верх этой функции. Всю её можно посмотреть в файле <a href="https://github.com/yurijvolkov/sysProgrammingProject/blob/master/vm_fsharp/Exec.fs">Exec.fs</a>.
Например, при получении команды LOAD мы берём 8-байтное значение, которое заинлайнено сразу за кодом команды LOAD и кладём его на стек данных. Переопределяем текущее состояние виртуальной машины :<ul>
	<li>Изменяем состояние стека данных </li>
        <li>Изменяем состояние верхнего контекста </li>
</ul>
И делаем рекурсивный вызов функции execute. Таким образом мы зацикливаем исполнение машины.  
Тут, конечно, интересно было бы рассказать про реализацию каждой из 51 команды, потому что многие из них содержат моменты, которые могут решаться разными способами, но к сожалению, это затянется на ещё несколько статей. Поэтому опишу лишь реализацию команд переходов. 
Главной головоломкой была организация прыжков назад, ведь, вспомним, в начале статьи я сказал, что мы будем хранить хвост из оставшихся команд и каждый раз "отрезать" верхнюю команду и исполнять её. То есть если нам надо перейти назад, у нас уже прыгать некуда.
Решил я эту проблему следующим образом : при прыжке назад, мы берем изначальный код функции, который мы можем получить, ведь в контексте хранится ссылка на instance функции. И от него отрезаем ровно столько, сколько нужно, чтобы попасть туда, куда нужно. Поначалу это решение казалось мне хорошим, но пообсуждав это с коллегами, мне предложили куда более интересный вариант. Мы можем перед исполнением кода, провести некое подобие статического анализа и для каждой команды перехода, получить обьект списка, который надо будет выполнить при соответствующем прыжке. И это решение оказывается очень крутым, если вспомнить, что списки иммутабельны, а поэтому полученные списки для каждого перехода, будут ссылаться на один и тот же список в памяти.  

<h3> Шаг 5: Тестирование виртуальной машины </h3>
Вот мы и написали языковую машину, и вроде она должна работать. Но я думаю не стоит объяснять, что тестировать её нужно, ведь мест чтобы накосячить было описано достаточно. Разумеется, до тех пор пока у нас нет компилятора, файлы для подачи загрузчику придётся собирать, как конструктор из байтиков.  
Для этого мы будем использовать ассемблер nasm. В каталоге <a href="https://github.com/yurijvolkov/sysProgrammingProject/tree/master/vm_fsharp/bin/Debug/tests">bin/Debug/tests </a>лежит <a href="https://github.com/yurijvolkov/sysProgrammingProject/blob/master/vm_fsharp/bin/Debug/tests/Makefile">Makefile</a>, который все файлы с расширением *.vt преобразует в файлы *.vtc, которые и подаются на вход загрузчику. Сам процесс написания тестов, я описывать не буду, лишь отмечу, что рядом с мейкфайлом лежат примеры тестов.

<h3> Выводы </h3>
В данной статье были описаны главные принципы работы стековой виртуальной машины, а главное подкреплены кодом. Надеюсь статья была интересная. 
Во второй части мы опишем процесс написания компилятора для Си-подобного языка, который будет генерировать код, исполняемый на описанной тут виртуальной машине. Спасибо!